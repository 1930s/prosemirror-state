const {schema, doc, blockquote, pre, p, li, ul, img, br, hr} = require("prosemirror-model/test/build")
const {TestState} = require("./state")
const assert = require("assert")

describe("Selection", () => {
  it("should follow changes", () => {
    let state = new TestState({doc: doc(p("hi")), schema})
    state.apply(state.tr.insertText("xy", 1))
    assert.equal(state.selection.head, 3)
    assert.equal(state.selection.anchor, 3)
    state.apply(state.tr.insertText("zq", 1))
    assert.equal(state.selection.head, 5)
    assert.equal(state.selection.anchor, 5)
    state.apply(state.tr.insertText("uv", 7))
    assert.equal(state.selection.head, 5)
    assert.equal(state.selection.anchor, 5)
  })

  it("should move after inserted content", () => {
    let state = new TestState({doc: doc(p("hi")), schema})
    state.textSel(2, 3)
    state.apply(state.tr.insertText("o"))
    assert.equal(state.selection.head, 3)
    assert.equal(state.selection.anchor, 3)
  })

  it("moves after an inserted leaf node", () => {
    let state = new TestState({doc: doc(p("foobar")), schema})
    state.textSel(4)
    state.apply(state.tr.replaceSelection(schema.node("horizontal_rule")))
    assert(state.doc.eq(doc(p("foo"), hr, p("bar"))), "split paragraph")
    assert.equal(state.selection.head, 7, "moved after rule")
    state.textSel(10)
    state.apply(state.tr.replaceSelection(schema.node("horizontal_rule")))
    assert(state.doc.eq(doc(p("foo"), hr, p("bar"), hr)), "inserted after")
    assert.equal(state.selection.from, 11, "selected hr")
  })

  it("allows typing over a leaf node", () => {
    let state = new TestState({doc: doc(p("a"), "<a>", hr, p("b")), schema})
    state.nodeSel(3)
    state.apply(state.tr.replaceSelection(schema.text("x")))
    assert(state.doc.eq(doc(p("a"), p("x"), p("b"))))
    assert.equal(state.selection.head, 5)
    assert.equal(state.selection.anchor, 5)
  })

  it("allows deleting a selected block", () => {
    let state = new TestState({doc: doc(p("foo"), ul(li(p("bar")), li(p("baz")), li(p("quux")))), schema})
    state.nodeSel(0)
    state.deleteSelection()
    assert(state.doc.eq(doc(ul(li(p("bar")), li(p("baz")), li(p("quux"))))), "paragraph vanished")
    assert.equal(state.selection.head, 3, "moved to list")
    state.nodeSel(2)
    state.deleteSelection()
    assert(state.doc.eq(doc(ul(li(p("baz")), li(p("quux"))))), "delete whole item")
    assert.equal(state.selection.head, 3, "to next item")
    state.nodeSel(9)
    state.deleteSelection()
    assert(state.doc.eq(doc(ul(li(p("baz"))))), "delete last item")
    assert.equal(state.selection.head, 6, "back to paragraph above")
    state.nodeSel(0)
    state.deleteSelection()
    assert(state.doc.eq(doc(p())), "delete list")
  })

  it("allows deleting a leaf", () => {
    let state = new TestState({doc: doc(p("a"), hr, hr, p("b")), schema})
    state.nodeSel(3)
    state.deleteSelection()
    assert(state.doc.eq(doc(p("a"), hr, p("b"))), "deleted first hr")
    assert.equal(state.selection.from, 3, "moved to second hr")
    state.deleteSelection()
    assert(state.doc.eq(doc(p("a"), p("b"))), "deleted second hr")
    assert.equal(state.selection.head, 4, "moved to paragraph")
  })

  it("properly handles deleting the selection", () => {
    let state = new TestState({doc: doc(p("foo", img, "bar"), blockquote(p("hi")), p("ay")), schema})
    state.nodeSel(4)
    state.apply(state.tr.replaceSelection(null))
    assert(state.doc.eq(doc(p("foobar"), blockquote(p("hi")), p("ay"))), "deleted img")
    assert.equal(state.selection.head, 4, "cursor at img")
    state.nodeSel(9)
    state.apply(state.tr.deleteSelection())
    assert(state.doc.eq(doc(p("foobar"), p("ay"))), "deleted blockquote")
    assert.equal(state.selection.from, 9, "cursor moved past")
    state.nodeSel(8)
    state.apply(state.tr.deleteSelection())
    assert(state.doc.eq(doc(p("foobar"))), "deleted paragraph")
    assert.equal(state.selection.from, 7, "cursor moved back")
  })

  it("can replace inline selections", () => {
    let state = new TestState({doc: doc(p("foo", img, "bar", img, "baz")), schema})
    state.nodeSel(4)
    state.apply(state.tr.replaceSelection(schema.node("hard_break")))
    assert(state.doc.eq(doc(p("foo", br, "bar", img, "baz"))), "replaced with br")
    assert.equal(state.selection.head, 5, "after inserted node")
    assert(state.selection.empty, "empty selection")
    state.nodeSel(8)
    state.apply(state.tr.replaceSelection(schema.text("abc")))
    assert(state.doc.eq(doc(p("foo", br, "barabcbaz"))), "replaced with text")
    assert.equal(state.selection.head, 11, "after text")
    assert(state.selection.empty, "again empty selection")
    state.nodeSel(0)
    state.apply(state.tr.replaceSelection(schema.text("xyz")))
    assert(state.doc.eq(doc(p("xyz"))), "replaced all of paragraph")
  })

  it("can replace a block selection", () => {
    let state = new TestState({doc: doc(p("abc"), hr, hr, blockquote(p("ow"))), schema})
    state.nodeSel(5)
    state.apply(state.tr.replaceSelection(schema.node("code_block")))
    assert(state.doc.eq(doc(p("abc"), pre(), hr, blockquote(p("ow")))), "replace with code block")
    assert.equal(state.selection.from, 7, "selection after")
    state.nodeSel(8)
    state.apply(state.tr.replaceSelection(schema.node("paragraph")))
    assert(state.doc.eq(doc(p("abc"), pre(), hr, p())), "replace with paragraph")
    assert.equal(state.selection.from, 9)
  })
})
